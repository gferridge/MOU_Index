---
title: "MOU_Index"
output: html_document
date: "2024-11-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(gcookbook)
library(ggrepel)
library(ggsci)
library(ggthemes)
library(NLP)
library(ggrepel)
library(worldfootballR)
library(jtools)
library(pwr)
library(ggalt)
library(stargazer)
library(stringi)
library(ellipsis)
library(moments)
install.packages("modelsummary")
library(modelsummary)
```


## Loading Data. In this instance just replace the read.csv with the command to access your personal version of this file.

```{r data}
DAVIESdata.2024.04.02 <- read.csv("~/DAVIESdata-2017-2024-raw.csv")
df <- DAVIESdata.2024.04.02
```

## Calculate Team Aggregates on DAVIES data (Minutes weighted)

```{r}
df_group <- df %>% group_by(League, Team, Season, Gen..Role) %>% 
    summarise(DAVIES_TOTAL = sum(DAVIES), 
              DAVIES_weighted = sum(DAVIES*Min)/sum(Min))
```

## Calculate League averages, STDevs and Vars for the same values. This is for alternative specifications.

```{r}
df_2 <- df_group %>% group_by(League, Season, Gen..Role) %>%
    summarise(League_DAVIES = mean(DAVIES_weighted),
              Raw_League_DAVIES = mean(DAVIES_TOTAL),
              SD_League = sd(DAVIES_weighted),
              Raw_SD_League = sd(DAVIES_TOTAL))
```

## Join these two datasets and create a Z score for each Team and Role for any future analysis

```{r}
df_together <- left_join(df_group,df_2, join_by(League, Season, Gen..Role))


df_together$Z <- (df_together$DAVIES_weighted - df_together$League_DAVIES)/df_together$SD_League
```

 At this point I see that the model is working as intended, with teams coming out that make a lot of sense. Manchester United's weakness in central defense, Barcelona's strength in creativity.


Now I want to add wages to the player data, which I'll do from scraping FBRef. This code does  a few different things. It firstly takes the nations that I would like it to (top 5 leagues) and gets league URLS for it for every year in the sample. It then scrapes these league sites for the team urls. It then scrapes wage data for all available team_urls, converts it into a single value from its initial state as a length one vector and then saves it as a csv which will be called instead from now on. This code can be skipped if there is a link to the csv. 

```{r, eval=FALSE, echo=FALSE}


nations <- c("GER", "ENG", "FRA", "ESP", "ITA")

league_urls <- c()

for (year in 2018:2024){
  for (nation in nations){
    new_urls <- fb_league_urls(country=nation, gender = "M", year, tier = "1st")
    league_urls <- c(league_urls, new_urls)
  }
}

team_urls <- c()
for (league in league_urls){
  new_urls <- fb_teams_urls(league, time_pause=3)
  team_urls <- c(team_urls, new_urls)
}


team_urls[team_urls != "https://fbref.com/en/squads/60b5e41f/2017-2018/Hannover-96-Stats"]

wage_data = data.frame()

get_wages <- function(urls, df){
  tryCatch(
    {
      for (url in urls){
        stringurl <- as.String(url)
        new_df <- fb_squad_wages(team_urls = url, time_pause = 5)
        df <- rbind(df, new_df)
      }
      error = function(e) {
        print(stringurl + " failed")
        print(e)
      }
      return(df)
    }
  )
}
wage_data <- get_wages(team_urls, wage_data)


wage_data = data.frame()

get_wages <- function(urls, df){
  results_list <- list()  # Use a list to store data frames
  for (url in urls) {
    tryCatch({
      new_df <- fb_squad_wages(team_urls = url, time_pause = 5)
      results_list[[url]] <- new_df
    }, error = function(e) {
      print(paste(url, "failed"))
      print(e$message)  # Print error message
    })
  }
  # Combine all data frames into one
  df <- do.call(rbind, results_list)
  return(df)
}

# Assuming team_urls is defined somewhere in your script
wage_data <- get_wages(team_urls, wage_data)

wage_data$WeeklyWageEUR <- as.String(wage_data$WeeklyWageEUR)

wage_data$WeeklyWageEUR <- sapply(wage_data$WeeklyWageEUR, function(x) { x[[1]] })
wage_data$WeeklyWageGBP <- sapply(wage_data$WeeklyWageGBP, function(x) { x[[1]] })
wage_data$WeeklyWageUSD <- sapply(wage_data$WeeklyWageUSD, function(x) { x[[1]] })
wage_data$AnnualWageEUR <- sapply(wage_data$AnnualWageEUR, function(x) { x[[1]] })
wage_data$AnnualWageGBP <- sapply(wage_data$AnnualWageGBP, function(x) { x[[1]] })
wage_data$AnnualWageUSD <- sapply(wage_data$AnnualWageUSD, function(x) { x[[1]] })

write.csv(wage_data, "wage_data.csv", row.names=FALSE)

```


## Use preprepared wage data instead of scraping

```{r}
wage_data <- read.csv("~/wage_data.csv")
```


## Transformations to alter wage data storage for future manipulation

```{r}

wage_data[] <- lapply(wage_data, function(x) if (is.list(x)) sapply(x, function(y) y[[1]], simplify = "vector") else x)

sapply(wage_data, is.list)

wage_data$WeeklyWageEUR <- sapply(wage_data$WeeklyWageEUR, function(x) {
  if (length(x) == 0 || is.null(x[[1]])) NA else as.numeric(x[[1]])
})

wage_data$WeeklyWageEUR <- vapply(wage_data$WeeklyWageEUR, function(x) {
  if (length(x) > 0 && !is.null(x[[1]])) as.numeric(x[[1]]) else NA
}, numeric(1))

wage_data$WeeklyWageGBP<- sapply(wage_data$WeeklyWageGBP, function(x) {
  if (length(x) == 0 || is.null(x[[1]])) NA else as.numeric(x[[1]])
})

wage_data$WeeklyWageGBP <- vapply(wage_data$WeeklyWageGBP, function(x) {
  if (length(x) > 0 && !is.null(x[[1]])) as.numeric(x[[1]]) else NA
}, numeric(1))

wage_data$WeeklyWageUSD <- sapply(wage_data$WeeklyWageUSD, function(x) {
  if (length(x) == 0 || is.null(x[[1]])) NA else as.numeric(x[[1]])
})

wage_data$WeeklyWageUSD <- vapply(wage_data$WeeklyWageUSD, function(x) {
  if (length(x) > 0 && !is.null(x[[1]])) as.numeric(x[[1]]) else NA
}, numeric(1))

wage_data$AnnualWageEUR <- sapply(wage_data$AnnualWageEUR, function(x) {
  if (length(x) == 0 || is.null(x[[1]])) NA else as.numeric(x[[1]])
})

wage_data$AnnualWageEUR <- vapply(wage_data$AnnualWageEUR, function(x) {
  if (length(x) > 0 && !is.null(x[[1]])) as.numeric(x[[1]]) else NA
}, numeric(1))

wage_data$AnnualWageGBP <- sapply(wage_data$AnnualWageGBP, function(x) {
  if (length(x) == 0 || is.null(x[[1]])) NA else as.numeric(x[[1]])
})

wage_data$AnnualWageGBP <- vapply(wage_data$AnnualWageGBP, function(x) {
  if (length(x) > 0 && !is.null(x[[1]])) as.numeric(x[[1]]) else NA
}, numeric(1))

wage_data$AnnualWageUSD <- sapply(wage_data$AnnualWageUSD, function(x) {
  if (length(x) == 0 || is.null(x[[1]])) NA else as.numeric(x[[1]])
})

wage_data$AnnualWageUSD <- vapply(wage_data$AnnualWageUSD, function(x) {
  if (length(x) > 0 && !is.null(x[[1]])) as.numeric(x[[1]]) else NA
}, numeric(1))

wage_data$WeeklyWageEUR <- wage_data$WeeklyWageEUR_num
```

## Add wage data to the original dataframe by player and season

```{r}
df_wage <- left_join(df, wage_data, by=c("Player", "Season"))
```


## Add in lags variables for previous seasons performance in order to figure out prediction models

```{r}
lags <- df_wage

lags <- lags %>%
  arrange(Player, Season) %>%  # Sort by player and season
  group_by(Player) %>%         # Group by player, but not reducing data
  mutate(
    stats_last_season = lag(DAVIES, 1),     # Stats from the previous season
    stats_2_seasons_ago = lag(DAVIES, 2),   # Stats from two seasons ago
    stats_3_seasons_ago = lag(DAVIES, 3),   # Stats from three seasons ago
    stats_4_seasons_ago = lag(DAVIES, 4),   # Stats from four seasons ago
    stats_5_seasons_ago = lag(DAVIES, 5),   # Stats from five seasons ago
    stats_6_seasons_ago = lag(DAVIES, 6)    # Stats from six seasons ago
  ) %>%
  ungroup()  # Optionally remove the grouping structure
```


## A couple of prediction models, selected from a larger suite. Linear Model 2 is used as prediction algorithm moving forward

```{r}
lm1 <- lm(DAVIES ~ WeeklyWageEUR+Age+League, df_wage)
lm2 <- lm(DAVIES ~ WeeklyWageEUR+League+Min+Age+Gen..Role, lags)
lm3 <- lm(DAVIES ~ WeeklyWageEUR+League+Min+Age+Gen..Role+stats_last_season, lags)
lm4 <- lm(DAVIES ~ WeeklyWageEUR+League+Min+Age+Gen..Role+stats_last_season+stats_2_seasons_ago, lags)

lm_wages <- lm(WeeklyWageEUR ~ Team.x+Season.Age+Gen..Role, df_wage)

stargazer(lm1,lm2,lm3,lm4, type="text")

```
# Generate a wage predictive algorithm here based on the lm_wages above, giving us an indication of what these players wages would have been. Its fidelity could be debated but it has an adjusted R^2 of 0.4831 which is sufficient for our purposes given that the quality of player that we are looking at here skews younger and will have less influence on our final results.

```{r}
# Step 1: Ensure the prediction model is fitted (assuming lm_wages is already fitted)

# Step 2: Predict the missing values for WeeklyWageEUR
na_indices <- which(is.na(df_wage$WeeklyWageEUR))  # Identify rows with NA
predicted_values <- predict(lm_wages, newdata = df_wage[na_indices, ])

stargazer(lm_wages, type="text")
# Step 3: Replace NA values with the predicted values
df_wage$WeeklyWageEUR[na_indices] <- predicted_values

df_wage
# The dataframe df_wage now has NA values replaced with predicted values in WeeklyWageEUR

```



## Generate Predictions for as many players as possible. Debatable assumption made here: players who do not have data from the previous season are assumed to have been purely average for their age, scoring a 0.

```{r}

lags2 <- lags

interested_leagues <- c("Premier League", "La Liga", "Serie A M", "Bundesliga", "Ligue 1")

# Filter the dataframe
filtered_lags2 <- lags2 %>%
  filter(League %in% interested_leagues)

# Display the filtered dataframe
df_predict <- filtered_lags2 %>%
  mutate(across(starts_with("stats"), ~replace_na(., 0)))

# Predict using the model
df_predict$predicted_stats <- predict(lm2, newdata = filtered_lags2, type = "response")

```


## Grouping these predictions by position group and league averages, much like I did for current season performance.

```{r}
grouped_predictions <- df_predict %>% group_by(League, Team.x, Season, Gen..Role) %>% 
  summarise(predicted_stats = sum(predicted_stats, na.rm=TRUE), 
            weighted_predictions = sum(predicted_stats*Min, na.rm=TRUE)/sum(Min, na.rm=TRUE))

league_predictions <- grouped_predictions %>% group_by(League, Season, Gen..Role) %>%
  summarise(League_predictions = mean(weighted_predictions),
            Raw_League_predictions = mean(predicted_stats),
            SD_predictions = sd(weighted_predictions),
            Raw_SD_predictions = sd(predicted_stats))


predictions_together <- left_join(grouped_predictions, league_predictions, join_by(League, Season, Gen..Role))
```

## Slight cleaning to make future analysis easier

```{r}

predictions_together$Z_predicted <- ifelse(predictions_together$SD_predictions > 0, (predictions_together$weighted_predictions - predictions_together$League_predictions)/predictions_together$SD_predictions, 0)

predictions_together$Team <- predictions_together$Team.x
```

## Combined data

```{r}
data_plus_predictions <- left_join(df_together, predictions_together, join_by(Team, Season, Gen..Role))
```


## Importing manager data

```{r}
Managers_DAVIES <- read.csv("~/Managers_DAVIES.csv")
data_plus_predictions$League <- data_plus_predictions$League.x
managers <- left_join(Managers_DAVIES, data_plus_predictions, join_by(League, Gen..Role, Team, Season))
```


## Linear models to look at the effect of individual managers

```{r}

lm5 <- lm(Z.x ~ Manager+Z_predicted, data=managers)
lm6 <- lm(DAVIES_weighted.y ~ Manager + weighted_predictions, managers)


lm6 <- lm(DAVIES_weighted.y ~ weighted_predictions, managers)


```


## Calculating aggregate DAVIES by position groups

```{r}

man2 <- managers

range(man2$DAVIES_weighted.x)
range(man2$weighted_predictions, na.rm=TRUE)

man2$DW_norm <- (man2$DAVIES_weighted.x+12)/35
man2$Weight_norm <- (man2$weighted_predictions+12)/35

range(man2$DW_norm)
range(man2$Weight_norm, na.rm=TRUE)

man2$mandex <- (man2$DW_norm-man2$Weight_norm)/man2$Weight_norm

range(man2$mandex, na.rm=TRUE)

man2 <- man2[order(-man2$mandex),]

```

### Index calculations for position groups

```{r}

man3 <- man2

man3 <- man3 %>% group_by(Manager, Gen..Role) %>% 
  summarise(Performance = mean(mandex, na.rm=TRUE), manager_count=n())

man3$max_seasons <- 7

man3$corrected_index <- man3$Performance/(man3$max_seasons-man3$manager_count +1)

man3$readable_index <- man3$corrected_index*100

man_CB <- man3[man3$Gen..Role=="Central Def",]
man_WB <- man3[man3$Gen..Role=="Wide Def",]
man_ST <- man3[man3$Gen..Role == "Finisher",]

man_ST <- man_ST[order(-man_ST$Performance),] 

man3 <- man3[order(-man3$corrected_index),]
```

The work up until this point has calculated an index stored in man3 by individual position groups. The rest of the code is focused on the recreation of this for full teams in order to create a central index.

## Total Teams


```{r}

df_all <- df
df_newpred <- df_predict

df_group2 <- df_all %>% group_by(League, Team, Season) %>% 
  summarise(DAVIES_TOTAL = sum(DAVIES), 
            DAVIES_weighted = sum(DAVIES*Min)/sum(Min))

df_3 <- df_group2 %>% group_by(League, Season) %>%
  summarise(League_DAVIES = mean(DAVIES_weighted),
            Raw_League_DAVIES = mean(DAVIES_TOTAL),
            SD_League = sd(DAVIES_weighted),
            Raw_SD_League = sd(DAVIES_TOTAL))

df_together2 <- left_join(df_group2,df_3, join_by(League, Season))
df_together2$Z <- (df_together2$DAVIES_weighted - df_together2$League_DAVIES)/df_together2$SD_League
```

## Generating predictions and binding those to the aggregated data

```{r}

grouped2 <- df_newpred %>% group_by(League, Team.x, Season) %>% 
  summarise(predictions = sum(predicted_stats, na.rm=TRUE), 
            weighted_predictions = sum(predicted_stats*Min, na.rm=TRUE)/sum(Min, na.rm=TRUE))

leagues2 <- grouped2 %>% group_by(League, Season) %>%
  summarise(League_predictions = mean(weighted_predictions),
            Raw_League_predictions = mean(predictions),
            SD_predictions = sd(weighted_predictions),
            Raw_SD_predictions = sd(predictions))


pred_tog <- left_join(grouped2, leagues2, join_by(League, Season))


pred_tog$Z_predicted <- ifelse(pred_tog$SD_predictions > 0, (pred_tog$weighted_predictions - pred_tog$League_predictions)/pred_tog$SD_predictions, 0)

pred_tog$Team <- pred_tog$Team.x

dpp2 <- left_join(df_together2, pred_tog, join_by(Team, Season))

dpp2$League <- dpp2$League.x
```
## Generating the Index and Ordering the dataframe by the index

```{r}
managers2 <- Managers_DAVIES

managers2 <- managers2 %>% group_by(Team, League, Season, Manager) %>%
  summarise(bogie= mean(DAVIES_TOTAL))
man_total <- left_join(dpp2, managers2, join_by(League, Team, Season))

lm5 <- lm(Z ~ Manager+Z_predicted, data=man_total)
lm6 <- lm(DAVIES_weighted ~ Manager + weighted_predictions, man_total)

range(man_total$DAVIES_weighted, na.rm=TRUE)
range(man_total$weighted_predictions, na.rm=TRUE)

man_total$DW_norm <- (man_total$DAVIES_weighted+2)/7
man_total$Weight_norm <- (man_total$weighted_predictions+2)/7


range(man_total$DW_norm, na.rm=TRUE)
range(man_total$Weight_norm, na.rm=TRUE)

man_total$mandex <- (man_total$DW_norm-man_total$Weight_norm)/man_total$Weight_norm


man_total <- man_total[order(-man_total$mandex),]



man_total_agg <- man_total %>% group_by(Manager) %>%
  summarise(index = mean(mandex, na.rm=TRUE), count=n())

man_total_agg <- man_total_agg[order(-man_total_agg$index),]

man_total_agg$max_seasons <- 7

man_total_agg$corrected_index <- man_total_agg$index/(man_total_agg$max_seasons-man_total_agg$count +1)

man_total_agg$readable_index <- man_total_agg$corrected_index*100
man_total_agg <- man_total_agg[order(-man_total_agg$readable_index),]
```



## Calibration by looking at Manager ELO

```{r}

managerELO <- read.csv("~/coaches_ranking.csv")


managerELO$Manager <- managerELO$Name

managerELO$Manager <- stri_trans_general(managerELO$Manager, "Latin-ASCII")
ELOvsINDEX <- left_join(man_total_agg, managerELO, by = "Manager")
```
### Testing correlation between them

```{r}
cor.test(ELOvsINDEX$Coach.Rating, ELOvsINDEX$corrected_index)
```

## Plotting this correlation

```{r}
# Calculate Pearson correlation, ignoring NA values
pearson_corr <- cor(ELOvsINDEX$corrected_index, ELOvsINDEX$Coach.Rating, use = "complete.obs")

# Create the ggplot with increased text size
ggplot(ELOvsINDEX, aes(x = corrected_index, y = Coach.Rating)) +
  geom_point(col = "black") +
  geom_smooth(method = "lm", se = FALSE, col="firebrick") +
  xlab("Index Value") +
  ylab("ELO") +
  theme_apa() +
  geom_text(aes(x = 0.25, y = 1950, label = paste("r =", round(pearson_corr, 3))), 
            size = 5, color = "black", hjust = 0) +  # Adjust text size for the correlation label
  theme(
    axis.title.x = element_text(size = 16),   # X-axis title text size
    axis.title.y = element_text(size = 16),   # Y-axis title text size
    axis.text.x = element_text(size = 14),    # X-axis labels text size
    axis.text.y = element_text(size = 14),    # Y-axis labels text size
    plot.title = element_text(size = 20, face = "bold")  # Plot title text size (optional)
  )

```

## Plotting the performance of the Predicted DAVIES vs Actual observed

```{r}

correlation <- cor(df_predict$predicted_stats, df_predict$DAVIES, use="complete.obs")
davies_vs_prediction <- ggplot(df_predict, aes(x = predicted_stats, y = DAVIES)) +
  geom_point(col = "black", size=0.25) +
  geom_smooth(method = "lm", se = FALSE, col="firebrick") +
  xlab("DAVIES Prediction") +
  ylab("Observed Value") +
  theme_apa()

ggsave("davies_vs_prediction.png", plot=davies_vs_prediction, dpi=600, width=6, height=4)

```




## Now we look to replicate and adjust using p90 data but following the same formula

# Data Loading

```{r}
DAVIES_p90 <- read.csv("~/DAVIESdata-2017-2024-p90.csv")
```

#Grouping by positional groups again

```{r}
group_p90 <- DAVIES_p90 %>% group_by(League, Team, Season, Gen..Role) %>% 
    summarise(DAVIES_TOTAL = sum(DAVIES), 
              DAVIES_weighted = sum(DAVIES*Min)/sum(Min))
```

# League Averages Calculated

```{r}
leagues.averages_p90 <- group_p90 %>% group_by(League, Season, Gen..Role) %>%
    summarise(League_DAVIES = mean(DAVIES_weighted),
              Raw_League_DAVIES = mean(DAVIES_TOTAL),
              SD_League = sd(DAVIES_weighted),
              Raw_SD_League = sd(DAVIES_TOTAL))
```

# Joining and Calculating Z Scores

```{r}
joint_p90 <- left_join(group_p90,leagues.averages_p90, join_by(League, Season, Gen..Role))


joint_p90$Z <- (joint_p90$DAVIES_weighted - joint_p90$League_DAVIES)/joint_p90$SD_League
```


# Add wage data in to this again

```{r}
df_wage_p90 <- left_join(DAVIES_p90, wage_data, by=c("Player", "Season", "Team"))
```


# Add in lags for p90 stats


## Add in lags variables for previous seasons performance in order to figure out prediction models

```{r}
lags_p90 <- df_wage_p90

lags_p90 <- lags_p90 %>%
  arrange(Player, Season) %>%  # Sort by player and season
  group_by(Player) %>%         # Group by player, but not reducing data
  mutate(
    stats_last_season = lag(DAVIES, 1),     # Stats from the previous season
    stats_2_seasons_ago = lag(DAVIES, 2),   # Stats from two seasons ago
    stats_3_seasons_ago = lag(DAVIES, 3),   # Stats from three seasons ago
    stats_4_seasons_ago = lag(DAVIES, 4),   # Stats from four seasons ago
    stats_5_seasons_ago = lag(DAVIES, 5),   # Stats from five seasons ago
    stats_6_seasons_ago = lag(DAVIES, 6)    # Stats from six seasons ago
  ) %>%
  ungroup()  # Optionally remove the grouping structure
```




## Formulating a good p90 prediction

```{r}

colnames(df_wage_p90)
lm1_p <- lm(DAVIES ~ WeeklyWageEUR+League, df_wage_p90)
lm2_p <- lm(DAVIES ~ WeeklyWageEUR+League+Age+Gen..Role, lags_p90)
lm3_p <- lm(DAVIES ~ WeeklyWageEUR+League+Age+stats_last_season, lags_p90)
lm4_p <- lm(DAVIES ~ WeeklyWageEUR+League+Min+Age+stats_last_season+stats_2_seasons_ago, lags_p90)

stargazer(lm1_p,lm2_p,lm3_p,lm4_p, type="text")

```

## The key is that a prediction algorithm can't use the actual onfield statistics from the season because those are the most endogenous things to a manager. We need to use all possible information not contained in these statistics.




### Testing Manager Season Percentage Assumption

```{r, eval=FALSE}
# Define leagues and years
leagues <- c("Spain", "Germany", "France", "Italy", "England")  # La Liga, Bundesliga, Ligue 1, Serie A, Premier League
years <- 2017:2023  # From 2017 to 2023

# Initialize an empty list to store data frames for each league-year combination
all_teams_list <- list()

# Loop over each league and year to get team URLs
for (league in leagues) {
  for (year in years) {
    # Fetch the team URLs for the league and year
    team_urls <- tm_league_team_urls(country_name = league, start_year = year)
    
    # Convert the result to a data frame and add columns for league and year
    league_df <- data.frame(
      league = league,
      year = year,
      team_url = team_urls,
      stringsAsFactors = FALSE
    )
    
    # Append the data frame to the list
    all_teams_list <- append(all_teams_list, list(league_df))
  }
}

# Combine all data frames into one and remove duplicates
all_teams <- do.call(rbind, all_teams_list)
all_teams <- unique(all_teams)
print(all_teams)
#----- then use the URLs to pass to the function, and select the role you wish to see results for: -----#
club_manager_history <- tm_team_staff_history(team_urls = all_teams$team_url, staff_role = "Manager")
dplyr::glimpse(club_manager_history)

club_manager_history

write.csv(club_manager_history, file= "club_manager_history.csv")

```

```{r}
club_manager_history <- read.csv("~/club_manager_history.csv")
```


# Player Valuation Data for Controls?

```{r}{eval=FALSE}
 big_5_valuations <- tm_player_market_values(country_name = c("England", "Spain", "Italy", "France", "Germany"),
                                        start_year = 2017:2023)
big_5_valuations

```




## Calculating Manager attribution with a variable threshold


# First putting in season dates

```{r}
# Create a DataFrame for season dates
season_start_dates <- as.Date(c('2017-08-01', '2018-08-01', '2019-08-01', 
                                '2020-08-01', '2021-08-01', '2022-08-01', 
                                '2023-08-01'))
season_end_dates <- as.Date(c('2018-07-31', '2019-07-31', '2020-07-31', 
                              '2021-07-31', '2022-07-31', '2023-07-31', 
                              '2024-07-31'))
seasons <- data.frame(
  season = c("2017/2018", "2018/2019", "2019/2020", "2020/2021", 
             "2021/2022", "2022/2023", "2023/2024"),
  start_date = season_start_dates,
  end_date = season_end_dates
)

```

```{r}
calculate_manager_attribution <- function(managers_df, seasons_df, threshold = 0.5) {
  # Check if columns exist in the managers dataframe
  if (!all(c("team_name", "staff_name", "appointed", "end_date") %in% colnames(managers_df))) {
    stop("Error: One or more required columns are missing from the managers dataframe.")
  }
  
  # Convert relevant columns to Date format if not already
  managers_df$appointed <- as.Date(managers_df$appointed)
  managers_df$end_date <- as.Date(managers_df$end_date)
  seasons_df$start_date <- as.Date(seasons_df$start_date)
  seasons_df$end_date <- as.Date(seasons_df$end_date)
  
  # Initialize an empty result dataframe
  result <- data.frame(team_name = character(), staff_name = character(), season = character(), stringsAsFactors = FALSE)
  
  for (i in 1:nrow(seasons_df)) {
    # Get the current season's start and end dates
    season_start <- seasons_df$start_date[i]
    season_end <- seasons_df$end_date[i]
    season_name <- seasons_df$season[i]
    
    for (j in 1:nrow(managers_df)) {
      # Access each manager's tenure and team/staff information explicitly with managers_df$
      appointed <- managers_df$appointed[j]
      end_date <- managers_df$end_date[j]
      team_name <- managers_df$team_name[j]
      staff_name <- managers_df$staff_name[j]
      
      # Handle missing values for appointed/end dates
      if (is.na(appointed)) next  # If appointed date is NA, skip
      if (is.na(end_date)) end_date <- Sys.Date()  # Assume manager is still active if end_date is NA
      
      # Calculate the overlap between the manager's tenure and the season
      overlap_start <- max(appointed, season_start, na.rm = TRUE)
      overlap_end <- min(end_date, season_end, na.rm = TRUE)
      
      # Ensure the overlap is valid
      if (!is.na(overlap_start) && !is.na(overlap_end) && overlap_start <= overlap_end) {
        days_in_season <- as.numeric(difftime(season_end, season_start, units = "days")) + 1
        days_managed <- as.numeric(difftime(overlap_end, overlap_start, units = "days")) + 1
        
        # Check if the manager was in charge for more than the threshold of the season
        if ((days_managed / days_in_season) >= threshold) {
          # Add the result to the dataframe
          result <- rbind(result, data.frame(
            team_name = team_name,
            staff_name = staff_name,
            season = season_name,
            stringsAsFactors = FALSE
          ))
        }
      }
    }
  }
  
  return(result)
}


# Example: Apply the function to the manager and season dataframes
attributed_managers <- calculate_manager_attribution(club_manager_history, seasons, threshold = 0.501)
colnames(attributed_managers)
julian <- attributed_managers[attributed_managers$staff_name == "Marco Silva",]
print(julian)
attributed_managers_60 <- calculate_manager_attribution(club_manager_history, seasons, threshold = 0.6)

```

#Rename columns and prepare the data to be matched up properly

```{r}
attributed_managers <- attributed_managers %>%
  rename(manager = staff_name) %>%
  mutate(manager = stri_trans_general(manager, "Latin-ASCII"))

attributed_managers <- attributed_managers %>%
  arrange(team_name)

```

Now need to make sure the team names match up between the DAVIES data and the Transfermarkt data, which I know for a fact they do not in many instances. Chelsea FC vs just Chelsea for example, Olympique Lyon vs Lyonnais vs just Lyon.


## Fixing the team names together

```{r}
# Mapping table

### THE ISSUE IS HERE, NEED ALL TEAMS


mapping <- data.frame(
  original_name = c("1.FC Heidenheim 1846", "1.FC Köln", "1.FC Nuremberg", "1.FC Union Berlin",
                                    "1.FSV Mainz 05", "AC Ajaccio", "AC Milan", "AC Monza", "ACF Fiorentina",
                                    "AFC Bournemouth", "AJ Auxerre", "AS Monaco", "AS Roma","AS Saint-Étienne",
                                    "Amiens SC", "Angers SCO", "Arminia Bielefeld", "Arsenal FC", "Aston Villa",
                                    "Atalanta BC", "Athletic Bilbao","Atlético de Madrid", "Bayer 04 Leverkusen",
                                    "Bayern Munich", "Benevento Calcio", "Bologna FC 1909", "Borussia Dortmund",
                                    "Borussia Mönchengladbach", "Brentford FC", "Brescia Calcio", 
                                    "Brighton & Hove Albion","Burnley FC","CA Osasuna","CD Leganés",
                                    "Cagliari Calcio","Cardiff City", "Celta de Vigo", "Chelsea FC","Chievo Verona",
                                    "Clermont Foot 63","Crystal Palace","Cádiz CF", "Deportivo Alavés",
                                    "Deportivo de La Coruña", "Dijon FCO", "EA Guingamp", "ESTAC Troyes",
                                    "Eintracht Frankfurt", "Elche CF", "Everton FC", "FC Augsburg", "FC Barcelona",
                                    "FC Crotone", "FC Empoli", "FC Girondins Bordeaux","FC Lorient", "FC Metz", 
                                    "FC Nantes","FC Schalke 04", "FC Toulouse", "Fortuna Düsseldorf", 
                                    "Frosinone Calcio", "Fulham FC", "Genoa CFC", "Getafe CF","Girona FC",
                                    "Granada CF","Hamburger SV", "Hannover 96", "Hellas Verona", "Hertha BSC",
                                    "Huddersfield Town", "Inter Milan", "Juventus FC", "LOSC Lille", "Le Havre AC",
                                    "Leeds United","Leicester City", "Levante UD", "Liverpool FC", "Luton Town",
                                    "Manchester City", "Manchester United", "Montpellier HSC", "Málaga CF",
                                    "Newcastle United", "Norwich City", "Nottingham Forest", "Nîmes Olympique",
                                    "OGC Nice", "Olympique Lyon", "Olympique Marseille", "Paris Saint-Germain",
                                    "Parma Calcio 1913", "RB Leipzig", "RC Lens", "RC Strasbourg Alsace", 
                                    "RCD Espanyol Barcelona", "RCD Mallorca", "Rayo Vallecano", 
                                    "Real Betis Balompié", "Real Madrid", "Real Sociedad", "Real Valladolid CF",
                                    "SC Freiburg", "SC Paderborn 07", "SD Eibar", "SD Huesca",
                                    "SM Caen", "SPAL", "SS Lazio", "SSC Napoli", "SV Darmstadt 98", 
                                    "SV Werder Bremen", "Sevilla FC", "Sheffield United", "Southampton FC",
                                    "SpVgg Greuther Fürth", "Spezia Calcio", "Stade Brestois 29",
                                    "Stade Reims", "Stade Rennais FC", "Stoke City", "Swansea City",
                                    "TSG 1899 Hoffenheim", "Torino FC", "Tottenham Hotspur", "UC Sampdoria",
                                    "UD Almería", "UD Las Palmas", "US Cremonese", "US Lecce", "US Salernitana 1919",
                                    "US Sassuolo", "Udinese Calcio","Valencia CF", "Venezia FC", "VfB Stuttgart",
                                    "VfL Bochum", "VfL Wolfsburg", "Villarreal CF","Watford FC", 
                                    "West Bromwich Albion", "West Ham United", "Wolverhampton Wanderers"
                    ),
  standardized_name = c("Heidenheim", "Köln", "Nürnberg", "Union Berlin", "Mainz 05", "Ajaccio",
			 "Milan", "Monza", "Fiorentina", "Bournemouth", "Auxerre", "Monaco",
			"Roma",  "Saint-Étienne", "Amiens", "Angers", "Arminia", "Arsenal",
			"Aston Villa", "Atalanta", "Athletic Club", "Atlético Madrid", "Leverkusen", "Bayern Munich",
			"Benevento", "Bologna", "Dortmund", "M'Gladbach", "Brentford", "Brescia",
			"Brighton", "Burnley", "Osasuna", "Leganés", "Cagliari", "Cardiff City",
			"Celta Vigo", "Chelsea", "Chievo", "Clermont Foot", "Crystal Palace", "Cádiz",
			"Alavés", "La Coruña", "Dijon", "Guingamp", "Troyes", "Eint Frankfurt",
			"Elche", "Everton", "Augsburg", "Barcelona", "Crotone", "Empoli",
			"Bordeaux", "Lorient", "Metz", "Nantes", "Schalke 04", "Toulouse",
			"Düsseldorf", "Frosinone", "Fulham", "Genoa", "Getafe", "Girona",
			"Granada", "Hamburger SV", "Hannover 96", "Hellas Verona", "Hertha BSC", "Huddersfield",
			"Inter", "Juventus", "Lille", "Le Havre", "Leeds United", "Leicester City",
			"Levante", "Liverpool", "Luton Town", "Manchester City", "Manchester Utd", "Montpellier",
			"Málaga", "Newcastle Utd", "Norwich City", "Nott'ham Forest", "Nîmes", "Nice",
			"Lyon", "Marseille", "Paris S-G", "Parma", "RB Leipzig", "Lens",
			"Strasbourg", "Espanyol", "Mallorca", "Rayo Vallecano", "Betis", "Real Madrid",
			"Real Sociedad", "Valladolid", "Freiburg", "Paderborn 07", "Eibar", "Huesca",
			"Caen", "SPAL", "Lazio", "Napoli", "Darmstadt 98", "Werder Bremen",
			"Sevilla", "Sheffield Utd", "Southampton", "Greuther Fürth", "Spezia", "Brest",
			"Reims", "Rennes", "Stoke City", "Swansea City", "Hoffenheim", "Torino",
			"Tottenham", "Sampdoria", "Almería", "Las Palmas", "Cremonese", "Lecce",
			"Salernitana", "Sassuolo", "Udinese", "Valencia", "Venezia", "Stuttgart",
			"Bochum", "Wolfsburg", "Villareal", "Watford", "West Brom", "West Ham", "Wolves")
)

```

## And replacing them in the dataset

```{r}
# Join attributed_managers with the mapping table and update team_name
attributed_managers <- attributed_managers %>%
  left_join(mapping, by = c("team_name" = "original_name")) %>%
  mutate(team_name = ifelse(is.na(standardized_name), team_name, standardized_name)) %>%
  select(-standardized_name)  # Drop the temporary standardized_name column

attributed_managers$season <- gsub("/", "-", attributed_managers$season)
# View the updated data frame

attributed_managers <- attributed_managers %>%
  rename(
    Team = team_name,
    Season = season
  )
attributed_managers <- unique(attributed_managers)
print(attributed_managers)

```


# Join my new manager database to the original, and replicate the code to create a more accurate manager index

```{r}
managers <- left_join(data_plus_predictions, attributed_managers, by=c("Team", "Season"))

print(managers)
```

# Calculating total manager index values based on this

```{r}
team.stats.no.pos.groups <- df %>% group_by(League, Team, Season) %>% 
  summarise(DAVIES_TOTAL = sum(DAVIES), 
            DAVIES_weighted = sum(DAVIES*Min)/sum(Min))

league.stats.no.pos.groups <- team.stats.no.pos.groups %>% group_by(League, Season) %>%
  summarise(League_DAVIES = mean(DAVIES_weighted),
            Raw_League_DAVIES = mean(DAVIES_TOTAL),
            SD_League = sd(DAVIES_weighted),
            Raw_SD_League = sd(DAVIES_TOTAL))

team.stats.with.league <- left_join(team.stats.no.pos.groups,league.stats.no.pos.groups, join_by(League, Season))
team.stats.with.league$Z <- (team.stats.with.league$DAVIES_weighted - team.stats.with.league$League_DAVIES)/team.stats.with.league$SD_League
```
# Now add in predictions

```{r}
team.predictions.no.pos.groups <- df_predict %>% group_by(League, Team.x, Season) %>% 
  summarise(predictions = sum(predicted_stats, na.rm=TRUE), 
            weighted_predictions = sum(predicted_stats*Min, na.rm=TRUE)/sum(Min, na.rm=TRUE))

league.predictions.no.pos.groups <- team.predictions.no.pos.groups %>% group_by(League, Season) %>%
  summarise(League_predictions = mean(weighted_predictions),
            Raw_League_predictions = mean(predictions),
            SD_predictions = sd(weighted_predictions),
            Raw_SD_predictions = sd(predictions))


joint.team.predictions <- left_join(team.predictions.no.pos.groups, league.predictions.no.pos.groups, join_by(League, Season))


joint.team.predictions$Z_predicted <- ifelse(joint.team.predictions$SD_predictions > 0, (joint.team.predictions$weighted_predictions - joint.team.predictions$League_predictions)/joint.team.predictions$SD_predictions, 0)

joint.team.predictions$Team <- joint.team.predictions$Team.x

print(joint.team.predictions)

team.based.statistics <- left_join(team.stats.with.league, joint.team.predictions, join_by(Team, Season))

team.based.statistics$League <- team.based.statistics$League.x
```

# Now can bind with manager data to start to attribute to managers

```{r}

managers_index_final <- left_join(team.based.statistics, attributed_managers, join_by(Team, Season))

```

# Generate manager index values by season

```{r}

managers_index_final$DW_norm <- (managers_index_final$DAVIES_weighted+2)/7
managers_index_final$Weight_norm <- (managers_index_final$weighted_predictions+2)/7


range(managers_index_final$DW_norm, na.rm=TRUE)
range(managers_index_final$Weight_norm, na.rm=TRUE)

managers_index_final$mandex <- (managers_index_final$DW_norm- managers_index_final$Weight_norm)/managers_index_final$Weight_norm
managers_index_final <- managers_index_final[order(-managers_index_final$mandex),]
```

# Aggregate these by manager to then find the final index, corrected for seasons

```{r}

managers_index_all_seasons <- managers_index_final%>% group_by(manager) %>%
  summarise(index = mean(mandex, na.rm=TRUE), count=n())

managers_index_all_seasons <- managers_index_all_seasons[order(-managers_index_all_seasons$index),]

managers_index_all_seasons$max_seasons <- 7

managers_index_all_seasons$corrected_index <- managers_index_all_seasons$index/(managers_index_all_seasons$max_seasons-managers_index_all_seasons$count +1)

managers_index_all_seasons$readable_index <- managers_index_all_seasons$corrected_index*100
managers_index_all_seasons <- managers_index_all_seasons[order(-managers_index_all_seasons$readable_index),]

print(managers_index_all_seasons)

dist_plot_index <- ggplot(data = managers_index_all_seasons, aes(x=corrected_index))+geom_histogram(col="black", fill="gray78", binwidth=0.005)+geom_density(size=1.1, col="red")+theme_apa()+xlab("Index Value")+ylab("Frequency")+geom_vline(xintercept=mean(managers_index_all_seasons$corrected_index), linetype="dashed", col="black", size=0.9)

ggsave("dist_plot_index.png", plot=dist_plot_index, dpi=600, width=6, height=4)

t.test(managers_index_all_seasons$corrected_index)
skewness(managers_index_all_seasons$corrected_index)
kurtosis(managers_index_all_seasons$corrected_index)

mean(managers_index_all_seasons$count)

```


## Charts necessary for paper

```{r}
managerELO$manager <- managerELO$Manager
ELOvsINDEX <- left_join(managers_index_all_seasons, managerELO, by = "manager")
cor.test(ELOvsINDEX$Coach.Rating, ELOvsINDEX$corrected_index)
```

## Plotting this correlation

```{r}
# Calculate Pearson correlation, ignoring NA values
pearson_corr <- cor(ELOvsINDEX$corrected_index, ELOvsINDEX$Coach.Rating, use = "complete.obs")

# Create the ggplot with increased text size
index_vs_ELO <- ggplot(ELOvsINDEX, aes(x = corrected_index, y = Coach.Rating)) +
  geom_point(col = "black", size=0.25) +
  geom_smooth(method = "lm", se = FALSE, col="firebrick") +
  xlab("Index Value") +
  ylab("Elo") +
  theme_apa()  # Adjust text size for the correlation label


ggsave("index_vs_ELO.png", plot=index_vs_ELO, dpi=600, width=6, height=4)


### Interesting Data Visualizations that are possible with existing data

```



## Position Group Analysis for Final Paper

First, the grouping of players and predictions by position group as well as role
```{r}
team.stats.pos.groups <- df %>% group_by(League, Team, Season, Gen..Role) %>% 
  summarise(DAVIES_TOTAL = sum(DAVIES), 
            DAVIES_weighted = sum(DAVIES*Min)/sum(Min))

league.stats.pos.groups <- team.stats.pos.groups %>% group_by(League, Season, Gen..Role) %>%
  summarise(League_DAVIES = mean(DAVIES_weighted),
            Raw_League_DAVIES = mean(DAVIES_TOTAL),
            SD_League = sd(DAVIES_weighted),
            Raw_SD_League = sd(DAVIES_TOTAL))

team.stats.with.league.pos <- left_join(team.stats.pos.groups,league.stats.pos.groups, join_by(League, Season, Gen..Role))
team.stats.with.league.pos$Z <- (team.stats.with.league.pos$DAVIES_weighted - team.stats.with.league.pos$League_DAVIES)/team.stats.with.league.pos$SD_League
```


Now perform the same operation with predicted values
```{r}
team.predictions.pos.groups <- df_predict %>% group_by(League, Team.x, Season, Gen..Role) %>% 
  summarise(predictions = sum(predicted_stats, na.rm=TRUE), 
            weighted_predictions = sum(predicted_stats*Min, na.rm=TRUE)/sum(Min, na.rm=TRUE))

league.predictions.pos.groups <- team.predictions.pos.groups %>% group_by(League, Season, Gen..Role) %>%
  summarise(League_predictions = mean(weighted_predictions),
            Raw_League_predictions = mean(predictions),
            SD_predictions = sd(weighted_predictions),
            Raw_SD_predictions = sd(predictions))


joint.team.predictions.pos <- left_join(team.predictions.pos.groups, league.predictions.pos.groups, join_by(League, Season, Gen..Role))


joint.team.predictions.pos$Z_predicted <- ifelse(joint.team.predictions.pos$SD_predictions > 0, (joint.team.predictions.pos$weighted_predictions - joint.team.predictions.pos$League_predictions)/joint.team.predictions.pos$SD_predictions, 0)

joint.team.predictions.pos$Team <- joint.team.predictions.pos$Team.x

team.based.statistics.pos <- left_join(team.stats.with.league.pos, joint.team.predictions.pos, join_by(Team, Season, Gen..Role))

team.based.statistics.pos$League <- team.based.statistics.pos$League.x
```

Now join with manager data
```{r}
managers_index_final.pos <- left_join(team.based.statistics.pos, attributed_managers, join_by(Team, Season))
```
Now generating the statistic itself

```{r}

managers_index_final.pos$DW_norm <- (managers_index_final.pos$DAVIES_weighted-min(managers_index_final.pos$DAVIES_weighted))/(max(managers_index_final.pos$DAVIES_weighted)-min(managers_index_final.pos$DAVIES_weighted)) *0.99+0.01

min(managers_index_final.pos$DAVIES_weighted)
max(managers_index_final.pos$DAVIES_weighted)

managers_index_final.pos$Weight_norm <- (managers_index_final.pos$weighted_predictions-min(managers_index_final.pos$weighted_predictions))/(max(managers_index_final.pos$weighted_predictions)-min(managers_index_final.pos$weighted_predictions)) *0.99+ 0.01


range(managers_index_final.pos$DW_norm, na.rm=TRUE)
range(managers_index_final.pos$Weight_norm, na.rm=TRUE)

managers_index_final.pos$mandex <- (managers_index_final.pos$DW_norm- managers_index_final.pos$Weight_norm)/managers_index_final.pos$Weight_norm
managers_index_final.pos <- managers_index_final.pos[order(-managers_index_final.pos$mandex),]
```

Okay and now doing this grouping by managers to get the values

```{r}

managers_index_all_seasons.pos <- managers_index_final.pos%>% group_by(manager, Gen..Role) %>%
  summarise(index = mean(mandex, na.rm=TRUE), count=n())

managers_index_all_seasons.pos <- managers_index_all_seasons.pos[order(-managers_index_all_seasons.pos$index),]

managers_index_all_seasons.pos$max_seasons <- 7

managers_index_all_seasons.pos$corrected_index <- managers_index_all_seasons.pos$index/(managers_index_all_seasons.pos$max_seasons-managers_index_all_seasons.pos$count +1)

managers_index_all_seasons.pos$readable_index <- managers_index_all_seasons.pos$corrected_index*100
managers_index_all_seasons.pos <- managers_index_all_seasons.pos[order(-managers_index_all_seasons.pos$readable_index),]

tail(managers_index_all_seasons.pos,10)

range(managers_index_all_seasons.pos$corrected_index)

```


## Now let's look at Dyche and Pep/Klopp and make the charts

Dyche
```{r}
dyche <- managers_index_all_seasons.pos[managers_index_all_seasons.pos$manager == "Sean Dyche",]

pepklopp <- managers_index_all_seasons.pos[managers_index_all_seasons.pos$manager == "Jurgen Klopp" | managers_index_all_seasons.pos$manager == "Pep Guardiola",]

pepklopp <- na.omit(pepklopp)

pepkloppchart <- ggplot(pepklopp, aes(x = reorder(Gen..Role, -corrected_index), y = corrected_index, fill = manager)) +
  geom_bar(stat = "identity", position = "dodge", width=0.4) +
  scale_fill_manual(values = c("#D10022", "#84BBFF")) +
  labs(
    x = "Position Group",
    y = "Index Value",
    fill = "Manager",
  ) +
  theme_apa()+
  theme(legend.text = element_text(size = 10),  # Adjust legend text size
    legend.key.size = unit(0.4, "cm"),      # Adjust legend key size
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10))

ggsave("pepkloppchart.png", pepkloppchart, dpi=600, width=6, height=4)

dyche <- na.omit(dyche)
dychechart <- ggplot(dyche, aes(x = reorder(Gen..Role, -corrected_index), y = corrected_index)) +
  geom_bar(stat = "identity", position = "dodge", width=0.4, fill="#0052CC") +
  labs(
    x = "Position Group",
    y = "Index Value"
  ) +
  theme_apa()

ggsave("dychechart.png", dychechart, dpi=600, width=6, height=4)


```

